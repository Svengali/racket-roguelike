#lang racket

(provide 
 get-tile
 for-tile
 ascend
 descend
 get-npcs
 update-npcs)

(require
 (only-in racket/gui queue-callback)
 "point.rkt"
 "entities.rkt"
 "items.rkt"
 "noise/noise.rkt"
 "thing/thing.rkt"
 "animate.rkt")

; Level defintions
; tile-gen : x y -> tile
; npc-gen  : x y -> npc or #f
; item-gen : x y -> item or #f
(define-struct level-definition (tile-gen npc-gen item-gen))

; All levels 
; (pt x y) : tile
; 'npcs    : list of npcs
; 'gen     ; level definition (see above)
; 'seed    ; a random seed [0,1) generated once per level
(define levels (make-hasheq))
(define current-depth (make-parameter 0))

; Generate a new level (if it doesn't already exist)
(define (get-level depth)
  (unless (hash-has-key? levels depth)
    (define level (make-hash))
    (hash-set! level 'seed (random))
    (hash-set! level 'npcs '())
    (hash-set! level 'gen
      (cond
        [(= depth 0) 
         (level-definition surface nothing nothing)]
        [else
         (level-definition shallow-cave rats-and-bombs base-items)]))
    (hash-set! levels depth level))
  (hash-ref levels depth))

; Loop over all generated tiles on the current level to update them
; f : x y tile -> void
(define (for-tile f)
  (for ([(pt tile) (in-hash (get-level (current-depth)))]
        #:when (pt? pt))
    (f (pt-x pt) (pt-y pt) tile)))

; Ascend or descend to a (potentially) new level
(define (ascend) (current-depth (+ (current-depth) 1)))
(define (descend) (current-depth (- (current-depth) 1)))

; Get the NPCs on the current level
(define (get-npcs)
  (hash-ref (get-level (current-depth)) 'npcs))

; Update npcs
(define (update-npcs world)
  (define current-level (get-level (current-depth)))
  (define npcs (hash-ref current-level 'npcs))
  
  ; Allow each to move
  (for ([npc (in-list npcs)])
    (thing-call npc 'act npc world))
  
  ; Check for (and remove) any dead npcs
  (hash-set! current-level 'npcs
    (filter 
     (lambda (npc)
       (when (<= (thing-get npc 'health) 0)
         (send world log (format "~a has died" (thing-get npc 'name))))
       (> (thing-get npc 'health) 0))
     npcs)))

; Fetch a tile
(define (get-tile x y)
  (define current-level (get-level (current-depth)))
  (define seed (hash-ref current-level 'seed))
  
  ; If the tile doesn't already exist, generate it
  (unless (hash-has-key? current-level (pt x y))
    ; Get the new tile
    ; Copy the tile here so that they don't share state
    (define new-tile 
      (let ([base-tile ((level-definition-tile-gen (hash-ref current-level 'gen)) seed x y)])
        (make-thing base-tile)))
    (hash-set! current-level (pt x y) new-tile) 
    
    ; NPCs and items are only on walkable tiles
    (when (thing-get new-tile 'walkable)
      ; (Potentially) generate a new npc
      (define new-npc ((level-definition-npc-gen (hash-ref current-level 'gen)) seed x y))
      (when (and (not (void? new-npc)) new-npc)
        (let ([new-npc (make-thing new-npc [location (pt x y)])])
          (hash-set! current-level 'npcs (cons new-npc (hash-ref current-level 'npcs)))))
      
      ; (Potentially) generate a new item for that tile
      ; Do not generate an item if there already is one (generated by the tile generation routine)
      (when (null? (thing-get new-tile 'items '()))
        (define new-item ((level-definition-item-gen (hash-ref current-level 'gen)) seed x y))
        (when (and (not (void? new-item)) new-item)
          (let ([new-item (make-thing new-item)])
            (thing-set! new-tile 'items (cons new-item (thing-get new-tile 'items))))))))
  
  ; Return the tile (newly generated or not)
  (hash-ref current-level (pt x y)))

; Look up a thing from a vector by 'name
(define (lookup vec name)
  (let/ec return
    (for ([thing vec]
          #:when (equal? name (thing-get thing 'name #f)))
      (return thing))
    (return #f)))
                
; ===== Basic tile definitions =====

(define-thing tile
  [character #\space]
  [color "black"]
  [items '()]
  [lighting 'dark]    ; Dark: Invisible; Fog: Only show tile, not NPC or item; Lit: Everything
  [walkable #f]       ; Can the player walk on this tile?
  [solid #f]          ; Does this tile block light?
  )

(define-thing empty tile
  [walkable #t])

(define-thing grass tile
  [character #\.]
  [color "green"]
  [walkable #t])

(define-thing wall tile
  [solid #t]
  [character #\#]
  [color "white"])

(define-thing water tile
  [character #\u00db]
  [color "blue"])

(define-thing tree tile
  [solid #t]
  [character #\u0005]
  [color "green"])

(define-thing stairs-up tile
  [character #\<]
  [color "gold"]
  [walkable #t]
  [(on-enter entity world)
   (when (eq? (send world get-player) entity)
     (ascend)
     (hash-set! (get-level (current-depth)) 
                (thing-get (send world get-player) 'location)
                (make-thing stairs-up)))])

(define-thing stairs-down tile
  [character #\>]
  [color "gold"]
  [walkable #t]
  [(on-enter entity world)
   (when (eq? (send world get-player) entity)
     (descend)
     (hash-set! (get-level (current-depth)) 
                (thing-get (send world get-player) 'location)
                (make-thing stairs-up)))])

; ===== Tile generation routines =====

; The surface level with grass, water, and trees
(define (surface seed x y)
  (define water? (> (simplex (* 0.1 x) seed      (* 0.1 y)) 0.5))
  (define tree?  (> (simplex seed      (* 0.1 x) (* 0.1 y)) 0.5))
  (cond
    [water? (make-thing water)]
    [tree?  (make-thing tree)]
    [else   (if (zero? (random 1000)) stairs-down grass)]))

; Generate a simple cave with water and trees
(define (shallow-cave seed x y)
  (define wall?  (> (simplex (* 0.1 x) (* 0.1 y) seed)      0))
  (define water? (> (simplex (* 0.1 x) seed      (* 0.1 y)) 0.5))
  (define tree?  (> (simplex seed      (* 0.1 x) (* 0.1 y)) 0.5))
  (cond
    [wall?  (make-thing wall)]
    [water? (make-thing water)]
    [tree?  (make-thing tree)]
    [else   (if (zero? (random 1000)) stairs-down empty)]))

; ===== NPC generation routines =====

; No NPCs (also works for items)
(define (nothing seed x y) #f)

; Rats. All of the rats.
(define (rats-only seed x y)
  (when (zero? (random 100))
    (lookup *entities* "rat")))

; Rats and bombs
(define (rats-and-bombs seed x y)
  (when (zero? (random 75))
    (lookup *entities* (if (zero? (random 2)) "rat" "bomb"))))

; ===== item generation routines =====

; Only basic items
(define (base-items seed x y)
  (when (zero? (random 1000))
    (case (random 4)
      [(0) (lookup *armors* "leather")]
      [(1) (lookup *weapons* "club")]
      [(2) (lookup *potions* "health potion")]
      [(3) (lookup *coins* "copper coin")])))